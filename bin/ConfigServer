#!/usr/bin/perl
#
########################################################################################################################
########################################################################################################################
##
##      Copyright (C) 2020 Peter Walsh, Milford, NH 03055
##      All Rights Reserved under the MIT license as outlined below.
##
##  FILE
##
##      ConfigServer
##
##  DESCRIPTION
##
##      RasPi configuration server
##
##      Accept commands from a web socket and perform that function.
##
##  USAGE
##
##      ConfigServer [-v]
##
##      where:      -v      Verbose: print out things as they happen
##
########################################################################################################################
########################################################################################################################
##
##  MIT LICENSE
##
##  Permission is hereby granted, free of charge, to any person obtaining a copy of
##    this software and associated documentation files (the "Software"), to deal in
##    the Software without restriction, including without limitation the rights to
##    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
##    of the Software, and to permit persons to whom the Software is furnished to do
##    so, subject to the following conditions:
##
##  The above copyright notice and this permission notice shall be included in
##    all copies or substantial portions of the Software.
##
##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
##    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
##    PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
##    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
##    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
##    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
##
########################################################################################################################
########################################################################################################################

use strict;
use warnings;
use Carp;

our $VERSION = 'AppDaemon2020-10-20';

use JSON;
use File::Slurp qw(read_file write_file);
use Socket;
use Clone 'clone';

use lib "/root/AppDaemon/lib";

use Site::IWList;
use Site::Process;
use Site::WSServer;
use Site::NetInfo;

########################################################################################################################
########################################################################################################################
##
## Data declarations
##
########################################################################################################################
########################################################################################################################

our $SERVER_PORT = 2021;

our $Server;

########################################################################################################################
########################################################################################################################
##
## Config server
##
########################################################################################################################
########################################################################################################################

#
# Process command line args.
#
#     -v (verbose) means "print out extra stuff"
#
my $Verbose = 0;

$Verbose = 1
    if defined $ARGV[0] and $ARGV[0] eq "-v";



use Data::Dumper;

my $NetDevs = GetNetDevs();
my $WPAInfo = GetWPAInfo();

print Data::Dumper->Dump([$NetDevs, $WPAInfo], [qw(NetDevs WPAInfo)]);

exit(0);




########################################################################################################################
########################################################################################################################
#
# Setup a web socket and listen for connections.
#
Message("ConfigServer is up and running.")
    if $Verbose;

Message("Waiting for websocket connection")
    if $Verbose;

Site::WSServer::InitWSServer($SERVER_PORT,[],\&WebRequest,\&ConnectionRequest)->start;

exit(1);

########################################################################################################################
########################################################################################################################
##
## ConnectionRequest - Process incoming connection requests
##
## Inputs:      Connection
##              Server
##
## Outputs:     TRUE  if should accept this request
##              FALSE if should reject this request
##
sub ConnectionRequest {

    kill "USR1",getppid         # Inform server of activity
        unless $DB::single;     #   (but not if debugging)

    return 1;
    }


########################################################################################################################
########################################################################################################################
##
## WebRequest - Process incoming web page requests
##
## Inputs:      JSON encoded struct of request
##              Connection
##              Server
##
## Outputs:     None
##
sub WebRequest {
    my $JSONText = shift // "";
    my $Conn     = shift;
    my $Server   = shift;
    
    kill "USR1",getppid         # Inform server of activity
        unless $DB::single;     #   (but not if debugging)

    #
    # Lots of error checking for web requests.
    #
    return Message("ConfigServer: No Web request")
        unless length $JSONText;

    my $Request = eval{decode_json $JSONText};              # Catches/avoids Croak() in lib function

    return Message("ConfigServer: Bad JSON Web request: ($JSONText)")
        unless defined $Request && (ref $Request) eq "HASH";

    $Request->{Type} //= "";
        
    return Message("WebRequest: No request type: ($JSONText)")
        unless length $Request->{Type};

    #
    # GetConfig - Return the complete system configuration struct
    #
    if( $Request->{Type} eq "GetConfig" ) {
        $Request->{Error} = "No error.";
        Message("ConfigServer: GetConfig()")
            if $Verbose;
        GetConfig($Request,$Verbose);
        $Conn->{OrigState} = clone($Request->{State});
        }

    #
    # SetConfig - Implement the user configuration
    #
    elsif( $Request->{Type} eq "SetConfig" ) {
        $Request->{Error} = "No error.";
        Message("ConfigServer: SetConfig()")
            if $Verbose;
        SetConfig($Request->{State},$Conn->{OrigState},$Verbose);
        }

    #
    # GetNetworks - Return list of networks
    #
    elsif( $Request->{Type} eq "GetNetworks" ) {
        Message("ConfigServer: GetNetworks()")
            if $Verbose;
        $Request->{Error} = "No error.";
        $Request->{State} = GetIWList();
        }

    #
    # UseWifi - Use the selected wifi/password
    #
    elsif( $Request->{Type} eq "UseWifi" ) {
        my $SSID     = $Request->{Arg1};
        my $Password = $Request->{Arg2};
        Message("ConfigServer: UseWifi($SSID,$Password)")
            if $Verbose;
        $Request->{Error} = UseWifi($SSID,$Password);
        }

    #
    # Unknown request type: Return error to caller
    #
    else {
        Message("ConfigServer: Unknown request type ($Request->{Type})")
            if $Verbose;
        }

    #
    # Pack up the error message and return the struct to the caller
    #
    SendResponse($Conn,$Request);
    }


########################################################################################################################
########################################################################################################################
##
## GetConfig - Read (and return) configuration info for system
##
## Inputs:      Server request packet
##              TRUE if verbose mode
##
## Outputs:     None
##
sub GetConfig {
    my $Request = shift;
    my $Verbose = shift;

    my $State;

    $State->{WifiPage}     = {};
    $State->{SysNamePage}  = {};
    $State->{WLanPage}     = {};
    $State->{ELanPage}     = {};
    $State->{SharingPage}  = {};
    $State->{AboutPage}    = [];

    #################################################
    #
    # "SysNamePage" page has system information
    #
    my $SysName = `cat /etc/hostname | tr -d " \t\n\r"`;
       $SysName = inet_ntoa(scalar gethostbyname('localhost'))
            unless length($SysName) and $SysName ne "";

    $State->{SysNamePage}{Name} = $SysName;

    Message("ConfigServer: GetConfig(SysName  ) => $State->{SysNamePage}{Name}")
            if $Verbose;

    #################################################
    #
    # Wifi page has the SSID and password
    #
    # network={
    #     ssid="$SSID"
    #     psk="$Password"
    #     }
    #
    our $ConfFile = "/etc/wpa_supplicant/wpa_supplicant.conf";

    $State->{SSIDPage}{    SSID} = `grep ssid $ConfFile`;
    $State->{SSIDPage}{Password} = `grep psk $ConfFile`;
    $State->{SSIDPage}{    SSID} =~ s/^.*ssid=\"(.+)\".*$/$1/;
    $State->{SSIDPage}{Password} =~ s/^.*psk=\"(.+)\".*$/$1/;
    chomp $State->{SSIDPage}{    SSID};
    chomp $State->{SSIDPage}{Password};

    #################################################
    #
    # "WLanPage" has network device info
    #
#    $State->{WLanPage} = ParseDHCP("wlan0");

    #################################################
    #
    # "ELanPage" has network device info
    #
#    $State->{ELanPage} = ParseDHCP("eth0");

    #################################################
    #
    # "AboutPage" has system information
    #
    my @Info = `hostnamectl`;
    chomp @Info;

    push @{$State->{AboutPage}}, $Info[0];        # "   Static hostname: raspberrypi"
    push @{$State->{AboutPage}}, $Info[4];        # "  Operating System: Raspbian GNU/Linux 10 (buster)"
    push @{$State->{AboutPage}}, $Info[5];        # "            Kernel: Linux 5.4.51-v7l+"
    push @{$State->{AboutPage}}, $Info[6];        # "      Architecture: arm"

    foreach my $Line (read_file("../etc/about")) {
        chomp $Line;

        next
            if substr($Line,0,1) eq "#";

        push @{$State->{AboutPage}}, $Line        # Product application info
        }        

    if( $Verbose ) {
        Message("ConfigServer: GetConfig(AboutPage) => $_")
            foreach @{$State->{AboutPage}};
        }

    $Request->{State} = $State;
    }


########################################################################################################################
########################################################################################################################
##
## SetConfig - Set the specified config
##
## Inputs:      Requested config state
##              Original  config state (for comparison)
##              TRUE if verbose mode
##
## Outputs:     None
##
sub SetConfig {
    my $NewState  = shift;
    my $OrigState = shift;
    my $Verbose  = shift;


    }


########################################################################################################################
########################################################################################################################
##
## ParseDHCP - Parse the DHCP config file and return info for device
##
## Inputs:      Device to scan for (ie "wlan0")
##
## Outputs:     Struct of device info
##
##  $Device->{Name}         Name of device (ie - "wlan0")
##         ->{Static}       No static description found
##         ->{IP}           IPV4 static address
##         ->{Mask}         Mask
##         ->{Router}       Router
##         ->{DNS1}         Domain name server 1
##         ->{DNS2}         Domain name server 2
##
#sub ParseDHCP {
#    my $DeviceName = shift;
#
#    my $Device = { Name => $DeviceName, Static => 0 };
#
#    my @DHCPConfigLines = read_file($DHCPConfigFile);
#
#    #
#    # interface wlan0
#    #     static ip_address=192.168.1.31
#    #     static routers=192.168.1.1
#    #     static domain_name_servers=1.1.1.1 1.0.0.1
#    #
#    my $State  = "Device";
#    foreach my $Line (@DHCPConfigLines) {
#        chomp $Line;
#
#        if( $State eq "Device" ) {
#            next
#                unless $Line =~ /^interface\s*$DeviceName/;
#
#            $State = "Block";
#            next;
#            }
#
#        if( $State eq "Block" ) {
#            last
#                unless length($Line);
#
#            $Device->{IP} = $1
#                if $Line =~ /^\s*static\s*ip_address=(\d*\.\d*\.\d*\.\d*\/\d*)/;
#
#            $Device->{Router} = $1
#                if $Line =~ /^\s*static\s*routers=(\d*\.\d*\.\d*\.\d*)/;
#
#            if( $Line =~ /^\s*static\s*domain_name_servers=(\d*\.\d*\.\d*\.\d*)\s*(\d*\.\d*\.\d*\.\d*)/ ) {
#                $Device->{DNS1} = $1;
#                $Device->{DNS2} = $2;
#                }
#            }
#        }
#
#    #
#    # Statically defined if there exists an IP, Router, and at least 1 DNS specified
#    #
#    $Device->{Static} = ($Device->{IP}     ne undef) &&
#                        ($Device->{Router} ne undef) &&
#                        ($Device->{DNS1}   ne undef);
#
#    $Device->{Static} = 0
#        unless $Device->{Static};               # Fix ideopathic problem in javascript
#
#    return $Device;
#    }


########################################################################################################################
########################################################################################################################
##
## UseWifi - Set the system to use the selected wifi
##
## Inputs:      Name of wifi to use
##              Password to use
##
## Outputs:     None
##
sub UseWifi {
    my $SSID     = shift;
    my $Password = shift;

my $wpa_text = <<"END_WPA";

ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=US

network={
    ssid="$SSID"
    psk="$Password"
    }
END_WPA

#    write_file($WPAConfigFile,$wpa_text);
    }
